{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation for the pg-entity library Welcome to pg-entity 's documentation, and thank you for your interest. You will find four parts in this documentation: The Tutorial: Where you will be guided to start a project and use the library; The How-to guides: Where precise usecases are described; The Reference: Where everything is explained.","title":"Home"},{"location":"#documentation-for-the-pg-entity-library","text":"Welcome to pg-entity 's documentation, and thank you for your interest. You will find four parts in this documentation: The Tutorial: Where you will be guided to start a project and use the library; The How-to guides: Where precise usecases are described; The Reference: Where everything is explained.","title":"Documentation for the pg-entity library"},{"location":"Tutorial/","text":"pg-entity tutorial Setting up our data-types First, import the following modules: import Data.Time ( UTCTime ) import Data.UUID ( UUID ) import Database.PostgreSQL.Entity ( insert ) import Database.PostgreSQL.Simple.FromField ( FromField ) import Database.PostgreSQL.Simple.FromRow ( FromRow ) import Database.PostgreSQL.Simple.ToField ( ToField ) import Database.PostgreSQL.Simple.ToRow ( ToRow ) import Database.PostgreSQL.Transact ( DBT ) Then, let us write down our initial data models for a blog. Author , and BlogPost . newtype AuthorId = AuthorId { getAuthorId :: UUID } deriving newtype ( Eq , Show , FromField , ToField ) data Author = Author { authorId :: AuthorId , name :: Text , createdAt :: UTCTime } deriving stock ( Eq , Generic , Show ) deriving anyclass ( FromRow , ToRow ) and newtype BlogPostId = BlogPostId { getBlogPostId :: UUID } deriving newtype ( Eq , FromField , Show , ToField ) data BlogPost = BlogPost { -- | Primary key blogPostId :: BlogPostId -- | Foreign key , authorId :: AuthorId , title :: Text , content :: Text , createdAt :: UTCTime } deriving stock ( Eq , Generic , Show ) deriving anyclass ( FromRow , ToRow ) Thankfully, the instances for FromRow and ToRow were easy enough that they could be automatically derived. Let us write the Entity instances now: instance Entity Author where tableName = \"authors\" primaryKey = \"author_id\" fields = [ \"author_id\" , \"name\" , \"created_at\" ] The above instance declaration reads as: My table's name is authors , its primary key is author_id , and the fields are author_id , name , and created_at . Let's do the same for BlogPost : instance Entity BlogPost where tableName = \"blogposts\" primaryKey = \"blogpost_id\" fields = [ \"blogpost_id\" , \"author_id\" , \"title\" , \"content\" , \"created_at\" ] Using Generics But this is a bit tedious, isn't it? Fortunately, there is a derivation mechanism available that allows you to do this: data Author = Author { authorId :: AuthorId , name :: Text , createdAt :: UTCTime } deriving stock ( Eq , Generic , Show ) deriving anyclass ( FromRow , ToRow ) deriving ( Entity ) via ( GenericEntity '[ TableName \"authors\" , PrimaryKey \"author_id\" ] Author ) Those two options, TableName and PrimaryKey are optional, and the library will adopt the following defaults: tableName will be the snake_case version of the record's name. No pluralisation will be done. primaryKey will be the snake_case version of the first field of the record. and more generally, field names are the snake_case version of the record fields. Writing the SQL migrations In a separate file, we will translate our Haskell data models into SQL migrations. create table authors ( author_id uuid primary key , name text not null , created_at timestamptz not null ); create table blogposts ( blogpost_id uuid primary key , author_id uuid not null , title text not null , content text not null , created_at timestamptz not null , constraint fk_author foreign key ( author_id ) references authors ( author_id ) ); Making queries By implementing the Entity Typeclass, your data-type has access to a variety of functions, combinators and helpers that serve the one true purpose of this library: Provide a safe mechanism to expand the fields of a table while writing a query. Let us define our insertion function for the Author model: insertAuthor :: Author -> DBT IO () insertAuthor = insert The result of this function, which is called a \u201cDBT action\u201d, is then passed to Database.PostgreSQL.Entity.DBT.runDB runDB :: ( MonadCatch m , MonadBaseControl IO m ) => ConnectionPool -- The connection pool, -- ideally taken from an environment ReaderT -> DBT m a -- The DB action, like `insert` -> m ( Either DBError a ) -- The return value You can then build a higher-level API endpoint or route controller like that: addAuthor :: ConnectionPool -> AuthorInfo -> IO () addAuthor pool info = do newAuthor <- mkAuthor info -- This functions is left to you result <- runDB pool $ insertAuthor newAuthor case result of Left err -> error \"Could not insert author! Error \" <> show err Right _ -> putTextLn \"Author \" <> ( name newAuthor ) <> \" added!\" And if you want to later select an Author based on its AuthorId : getAuthor :: ConnectionPool -> AuthorId -> IO ( Either DBError Author ) getAuthor pool authorId = runDB pool $ selectOneById ( Only authorId )","title":"Tutorial"},{"location":"Tutorial/#pg-entity-tutorial","text":"","title":"pg-entity tutorial"},{"location":"Tutorial/#setting-up-our-data-types","text":"First, import the following modules: import Data.Time ( UTCTime ) import Data.UUID ( UUID ) import Database.PostgreSQL.Entity ( insert ) import Database.PostgreSQL.Simple.FromField ( FromField ) import Database.PostgreSQL.Simple.FromRow ( FromRow ) import Database.PostgreSQL.Simple.ToField ( ToField ) import Database.PostgreSQL.Simple.ToRow ( ToRow ) import Database.PostgreSQL.Transact ( DBT ) Then, let us write down our initial data models for a blog. Author , and BlogPost . newtype AuthorId = AuthorId { getAuthorId :: UUID } deriving newtype ( Eq , Show , FromField , ToField ) data Author = Author { authorId :: AuthorId , name :: Text , createdAt :: UTCTime } deriving stock ( Eq , Generic , Show ) deriving anyclass ( FromRow , ToRow ) and newtype BlogPostId = BlogPostId { getBlogPostId :: UUID } deriving newtype ( Eq , FromField , Show , ToField ) data BlogPost = BlogPost { -- | Primary key blogPostId :: BlogPostId -- | Foreign key , authorId :: AuthorId , title :: Text , content :: Text , createdAt :: UTCTime } deriving stock ( Eq , Generic , Show ) deriving anyclass ( FromRow , ToRow ) Thankfully, the instances for FromRow and ToRow were easy enough that they could be automatically derived. Let us write the Entity instances now: instance Entity Author where tableName = \"authors\" primaryKey = \"author_id\" fields = [ \"author_id\" , \"name\" , \"created_at\" ] The above instance declaration reads as: My table's name is authors , its primary key is author_id , and the fields are author_id , name , and created_at . Let's do the same for BlogPost : instance Entity BlogPost where tableName = \"blogposts\" primaryKey = \"blogpost_id\" fields = [ \"blogpost_id\" , \"author_id\" , \"title\" , \"content\" , \"created_at\" ]","title":"Setting up our data-types"},{"location":"Tutorial/#using-generics","text":"But this is a bit tedious, isn't it? Fortunately, there is a derivation mechanism available that allows you to do this: data Author = Author { authorId :: AuthorId , name :: Text , createdAt :: UTCTime } deriving stock ( Eq , Generic , Show ) deriving anyclass ( FromRow , ToRow ) deriving ( Entity ) via ( GenericEntity '[ TableName \"authors\" , PrimaryKey \"author_id\" ] Author ) Those two options, TableName and PrimaryKey are optional, and the library will adopt the following defaults: tableName will be the snake_case version of the record's name. No pluralisation will be done. primaryKey will be the snake_case version of the first field of the record. and more generally, field names are the snake_case version of the record fields.","title":"Using Generics"},{"location":"Tutorial/#writing-the-sql-migrations","text":"In a separate file, we will translate our Haskell data models into SQL migrations. create table authors ( author_id uuid primary key , name text not null , created_at timestamptz not null ); create table blogposts ( blogpost_id uuid primary key , author_id uuid not null , title text not null , content text not null , created_at timestamptz not null , constraint fk_author foreign key ( author_id ) references authors ( author_id ) );","title":"Writing the SQL migrations"},{"location":"Tutorial/#making-queries","text":"By implementing the Entity Typeclass, your data-type has access to a variety of functions, combinators and helpers that serve the one true purpose of this library: Provide a safe mechanism to expand the fields of a table while writing a query. Let us define our insertion function for the Author model: insertAuthor :: Author -> DBT IO () insertAuthor = insert The result of this function, which is called a \u201cDBT action\u201d, is then passed to Database.PostgreSQL.Entity.DBT.runDB runDB :: ( MonadCatch m , MonadBaseControl IO m ) => ConnectionPool -- The connection pool, -- ideally taken from an environment ReaderT -> DBT m a -- The DB action, like `insert` -> m ( Either DBError a ) -- The return value You can then build a higher-level API endpoint or route controller like that: addAuthor :: ConnectionPool -> AuthorInfo -> IO () addAuthor pool info = do newAuthor <- mkAuthor info -- This functions is left to you result <- runDB pool $ insertAuthor newAuthor case result of Left err -> error \"Could not insert author! Error \" <> show err Right _ -> putTextLn \"Author \" <> ( name newAuthor ) <> \" added!\" And if you want to later select an Author based on its AuthorId : getAuthor :: ConnectionPool -> AuthorId -> IO ( Either DBError Author ) getAuthor pool authorId = runDB pool $ selectOneById ( Only authorId )","title":"Making queries"}]}